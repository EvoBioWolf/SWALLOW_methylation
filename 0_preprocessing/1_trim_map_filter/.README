## 0_Preprocessing

#### Quality check of raw sequencing runs (24.01.22-28.01.22)

Ran fastqc on all raw input files, output in folder /ra52qed/fastqc

multiqc reports in /Notes/documentation/multiqc

everything looks more or less good, one sample seems to be throwing way off in comparison to all the others

#### 1_Trimming (01.02.22-14.02.22)

So I want to use [TrimGalore]([TrimGalore/Trim_Galore_User_Guide.md at master · FelixKrueger/TrimGalore · GitHub](https://github.com/FelixKrueger/TrimGalore/blob/master/Docs/Trim_Galore_User_Guide.md))! to remove low quality bases, adapter sequences as well as C's that were involved in end repair, which could lead to mis-called methylated sites.

I used the following options in the script.

```bash
#-q removes low quality bases (<20) first for RRBS samples, then moves onto adapter removal
#--fastqc runs fastqc on the resulting .fastq file
#--gzip compresses output files
#--retain_unpaired keeps unpaired reads that one read was removed due to being too short after adapter removal/trimming
#--rrbs and --paired for our specific data
```

Fastqc output can be found in trim.galore.2501/fastqc

"Read 1 sequences with adapter contamination will be trimmed a further 2 bp from their 3' end, and Read 2 sequences will be trimmed by 2 bp from their 5' end to remove potential methylation-biased bases from the end-repair reaction
All Read 2 sequences will be trimmed by 2 bp from their 5' end to avoid poor qualities or biases (e.g. M-bias for BS-Seq applications)"

Because the cut site is at CGG the first bases are always C/T (depending on if it is methylated or not) followed by GG. The first site is a true methylation site, which can be mapped to the genome. Because this is a directional library, the first C on the 5' end will be a true methylation...however on the 3' end a C is added during A tailing. This was corrected for using the --rrbs function in trim_galore which trims 2 extra bases after the A, which should catch the last 'fake' C. See this [tutorial](https://www.bioinformatics.babraham.ac.uk/projects/bismark/RRBS_Guide.pdf) and [forum](https://www.biostars.org/p/9475211/) for more information.

All of the R2 reads begin with an A in the first base. At first, this seems like something is wrong, however, TrimGalore should have already trimmed 2 bases after the tailing A, which it has (GA) if we compare to the raw reads. This 100% 'A' composition is because after MspI cutting, the fragment will end in `CCG`. Now the first `C` is in non-CG context and as such is almost universally unmethylated. The middle`C` is the one that gets filled in during the end-repair procedure, and it get's filled in with unmethylated cytosines. This, after the end repair, fill-in reaction and bisulfite treatment, the fragment will always end in `TTG`. Thus, R2 will always start with `CAA` see [here](https://www.researchgate.net/post/Why_do_some_G_bases_read_as_A_bases_after_bisulfite_conversion_PCR_ampifcation_and_sequencing) for more information.

#### 2_Mapping (14.02.22-08.03.22)

All mapping scripts were based on information from Justin with modifications.

First, we have to prep the genome. This does the c->t conversions and g->a needed for mapping (0_bismark.genome.prep.sh)

```bash
bismark_genome_preparation /dss/dsslegfs01/pr53da/pr53da-dss-0034/assemblies/Hirundo.rustica/genome/v2/Hirundo.rustica_genome_bHirRus1_PacBio.Illumina.Hi-C.DLS_v2.fna
```

Now, we map the reads to the reference genome (1_bismark.map.sh)

```bash
workdir=/dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowGenomics/trim.galore
genome=/dss/dsslegfs01/pr53da/pr53da-dss-0034/assemblies/Hirundo.rustica/genome/v2
output=/dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowGenomics/bismark.map

while read f;
do bismark --parallel 5 --output_dir ${output} --genome ${genome} -1 ${f}__R1__*val_1* -2 ${f}__R2__*val_2*;
done < /dss/dsshome1/lxc0B/ra52qed/scripts/mueller/sample.names.txt
```

Finished on 11.02.2022. Here we end with a bam file for each sample

Sort bam files.

```bash
while read f;

        do samtools sort ${f}*.bam -o ${f}.sorted.bam;

done < /dss/dsshome1/lxc0B/ra52qed/scripts/mueller/sample.names.txt
```

See [here]([Bismark PE/SE directional and non-directional alignments · Issue #208 · FelixKrueger/Bismark · GitHub](https://github.com/FelixKrueger/Bismark/issues/208)) if we get unusally low mapping rates for data as it is a very similar experiment, the suggestions are:

1. see if the different trimming mode has an influence on the stats (doublechecked trimming, should be fine)
  
2. relax the `--score_min` function somewhat for the paired-end alignments, e.g. to `--score_min L,0,-0.4`
  
3. you could also think of specifying `--unmapped` during the PE alignment steps, and then use the unmapped reads in single-end mode to get the most out of your data. The commands for the SE data would then be: R1,`bismark --genome /your/genome/ R1_unmapped.fq.gz` and R2, `bismark --genome /your/genome/ --pbat R2_unmapped.fq.gz`
  

#### 3_Mapping Efficiency Check (10.03.22)

I want to quickly check the mapping efficiency (3_bismark.mapping.efficiency.sh) of this step using the following script, which pulls from the .report file produced by bismark. Qualimap does not perform accurately on bismark results.

```bash
while read f;

        do echo ${f}; awk 'NR==9 {print}' ${f}*report*;
        done < /dss/dsshome1/lxc0B/ra52qed/scripts/mueller/sample.names.full.txt
~                                                                                       
```

## Conversion Efficiency (21.02.22)

Determining [conversion efficiency]([Controlling for bisulfite conversion efficiency with a 1% Lamda spike-in - Enseqlopedia](http://enseqlopedia.com/2016/10/controlling-for-bisulfite-conversion-efficiency-with-a-1-lamda-spike-in/)) using DNA that is known to be unmethylated (like mtDNA, although there has since been critic of this method or what is now more common using unmethylated lambda phage DNA) is an important step as it tells us the conversion rate of Cs to Ts in our samples. This can be done by running essentially the same pipeline that we will use on our samples, except applying this to the lamda phage reference genome (see 4_bismark.lambda.sh).

```bash
workdir=/dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowGenomics/trim.galore
genome=/dss/dsslegfs01/pr53da/pr53da-dss-0034/assemblies/Escherichia.phage.Lambda
output=/dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowGenomics/mapping.efficency

#bismark_genome_preparation ${genome}

while read f;
do bismark --parallel 5  --output_dir ${output} --genome ${genome} -1 ${f}__R1__*val_1* -2 ${f}__R2__*val_2*; 
echo ${f}; awk 'NR==9 {print}' ${f}*report*;
done < /dss/dsshome1/lxc0B/ra52qed/scripts/mueller/sample.names.full.txt

cd ${output}
bismark_methylation_extractor -p --no_overlap --bedgraph --cytosine_report --output ${output}/methylation.extraction --parallel 8 --buffer_size 20G --genome_folder ${genome} *bismark_bt2_pe.bam

multiqc .
```

After then running multiqc on the output of this script, the output below was generated.

The percent of methylated cyotines (2nd column above), represents the inverse of the conversion efficieny, therefore our conversion efficiency is between 99.7-99.8%.

#### 5_Bismark Extraction (14.03.22-12.04.22)

```bash
#p is for paired end
##no_overlap is to only read CpG sites from overlapping R1 and R2 once

bismark_methylation_extractor -p --gzip --no_overlap --bedgraph --cytosine_report --output /dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowGenomics/bismark.map/bismark.extraction --parallel 8 --buffer_size 20G --genome_folder /dss/dsslegfs01/pr53da/pr53da-dss-0034/assemblies/Hirundo.rustica/genome/v2/ *bismark_bt2_pe.bam
```

This script is particularly slow. It should be submitted as each sample as its own job.

#### 5_Bismark Extraction Output Files (13.04.22-15.04.22)

Let's review what the output from each of the Bismark_extraction function is and contains (all examples come from <u>CH_18_R_18CH024_BL_ADL_M__SRR17643018__R1__d26a809a141ff3606bbb012b518a4454)</u>

The input was the {Sample_Name}_val_1_bismark_bt2_pe.bam

1. **{Sample_Name}_val_1_bismark_bt2_pe.bedGraph.gz**
  
  Chromosome/START/END/Percent_Methylation
  

```bash
scaffold318    2701    2702    0
scaffold318    2704    2705    100
scaffold318    2713    2714    100
scaffold496    17553    17554    100
scaffold496    17670    17671    100
scaffold517    3945    3946    100
scaffold568    7463    7464    66.6666666666667
scaffold568    7466    7467    100
scaffold568    7470    7471    66.6666666666667
```

This is actually covered in the bismark.cov (see below), so this may not be a necessary file to keep.

2. **{Sample_Name}_val_1_bismark_bt2_pe.bismark.cov.gz**
  
  Chrom/Start/End/Percent_Methylation/Count_Methylated/Count_Unmethylated
  

```bash
scaffold318    2702    2702    0    0    5
scaffold318    2705    2705    100    5    0
scaffold318    2714    2714    100    5    0
scaffold496    17554    17554    100    1    0
scaffold496    17671    17671    100    1    0
scaffold517    3946    3946    100    1    0
scaffold568    7464    7464    66.6666666666667    2    1
scaffold568    7467    7467    100    3    0
scaffold568    7471    7471    66.6666666666667    2    1
scaffold568    7555    7555    100    3    0
```

3. **{Sample_Name}_val_1_bismark_bt2_pe.CpG_report.txt**

This is genome based, and shows every single 'C' positions in a CpG context, therefore there will be many sites that show 0/0 for methylated/unmethylated counts.

Chromsome/Position/Strand/Count_Methylated/Count_Unmethylated/Dinucleotide/Trinucleotide

```bash
scaffold318    5    +    0    0    CG    CGG
scaffold318    6    -    0    0    CG    CGT
scaffold318    26    +    0    0    CG    CGT
scaffold318    27    -    0    0    CG    CGT
scaffold318    410    +    0    0    CG    CGT
scaffold318    411    -    0    0    CG    CGT
scaffold318    416    +    0    0    CG    CGT
scaffold318    417    -    0    0    CG    CGC
scaffold318    424    +    0    0    CG    CGA
scaffold318    425    -    0    0    CG    CGT
```

4. **{Sample_Name}_val_1_bismark_bt2_pe.cytosine_context_summary.txt**

This is a summary of the methylation within different genomic contexts. A short document (65 lines for each sample)

```bash
upstream    C-context    full context    count methylated    count unmethylated    percent methylation
A    CAA    ACAA    176    220    44.44
C    CAA    CCAA    1917    1967    49.36
G    CAA    GCAA    52    425    10.90
T    CAA    TCAA    26    103    20.16
A    CAC    ACAC    520    801    39.36
C    CAC    CCAC    289    615    31.97
G    CAC    GCAC    173    416    29.37
T    CAC    TCAC    73    161    31.20
A    CAG    ACAG    1260    2653    32.20
```

5. **{Sample_Name}_val_1_bismark_bt2_pe.M-bias.txt**
  
  File that shows across all reads from this individual, the percent methylation at each position of the read 1-150bp (because our reads are 150bp long maximum). This can show if there is some sort of technical bias at certain positions along the read...for example in RRBS sequencing you expect some non-random distribution at the beginning of reads due to cut-sites.
  
  ```bash
  CpG context (R1)
  ================
  position    count methylated    count unmethylated    % methylation    coverage
  1    8486092    8220754    50.79    16706846
  2    2713    3123    46.49    5836
  3    237    590    28.66    827
  4    336505    696438    32.58    1032943
  5    261273    510935    33.83    772208
  6    406506    609773    40.00    1016279
  7    403851    768120    34.46    1171971
  ```
  
6. **{Sample_Name}_val_1_bismark_bt2_PE_report.txt**
  

This is a summary of the mapping/alignment

```basic
Final Alignment report
======================
Sequence pairs analysed in total:    27881378
Number of paired-end alignments with a unique best hit:    18271283
Mapping efficiency:    65.5% 
Sequence pairs with no alignments under any condition:    6412839
Sequence pairs did not map uniquely:    3197256
Sequence pairs which were discarded because genomic sequence could not be extracted:    477

Number of sequence pairs with unique best (first) alignment came from the bowtie output:
CT/GA/CT:    9124899    ((converted) top strand)
GA/CT/CT:    0    (complementary to (converted) top strand)
GA/CT/GA:    0    (complementary to (converted) bottom strand)
CT/GA/GA:    9145907    ((converted) bottom strand)

Number of alignments to (merely theoretical) complementary strands being rejected in total:    0

Final Cytosine Methylation Report
=================================
Total number of C's analysed:    1279952049

Total methylated C's in CpG context:    90198288
Total methylated C's in CHG context:    2351163
Total methylated C's in CHH context:    3264316
Total methylated C's in Unknown context:    149578
```

7. **{Sample_Name}_val_1_bismark_bt2_pe_splitting_report.txt**
  
  A methylation report with some summary statistics on the called methylation
  
  ```basic
  Processed 18270806 lines in total
  Total number of methylation call strings processed: 36541612
  
  Final Cytosine Methylation Report
  =================================
  Total number of C's analysed:    687387707
  
  Total methylated C's in CpG context:    48686467
  Total methylated C's in CHG context:    1344289
  Total methylated C's in CHH context:    1788069
  
  Total C to T conversions in CpG context:    83327692
  Total C to T conversions in CHG context:    193520897
  Total C to T conversions in CHH context:    358720293
  
  C methylated in CpG context:    36.9%
  C methylated in CHG context:    0.7%
  C methylated in CHH context:    0.5%
  ```
  

##### 3_Qualimap Statistics

We can view the multiqc output that looks at alignment and mapping. There is an overall lower alignment than would be expected from WGS, however, this is to be expected.

We can plot the Percentage of Aligned Reads per sample to see how well mapping and alignment performed. This can be especially important as RRBS with default settings can have low mapping rates, making parameter testing key (see above). This uses a 'cleaned general stats file' with shorter sample IDs (adapt script in next section to suit the needs of the sample names.)

```r
df.multiqc <- read.table(file = "../1.4.bismark.extraction.0103/general.stats.txt", header=F)
colnames(df.multiqc)<- c("Sample_ID","p_cpg","p_chg", "p_chh", "total_reads", "aligned_reads", "percent_aligned")

ggplot(df.multiqc,aes(x=Sample_ID,y=percent_aligned))+
  geom_bar(stat="identity",position = "dodge")+
  theme_classic(base_size=16)+
  ylim(0,100)+
  ggtitle("% Aligned Reads using Bismark")+
  theme(axis.text.x=element_text(angle=90),axis.title.x=element_blank())
```

### 4_Merge symmtric CpG sites

#### Edited 09.08.23

I realized that I want to merge the symmetrical CpG sites from the different strands together to increase the coverage at each site. This is because in animal genomes the methylation from both strands generally reflects eachother and can theerfore be combined. I use a script from Robin Cristofari (penguin tools github) to merge CpG sites. This works on the CpG_report files and outputs a merged.cov file which has the same structure as the bismark.cov.gz files and can be piped directly into the filtering steps outlined below. I ran this script on all samples and then re-ran the calling steps below.

```bash
for i in *CpG_report.txt.gz; do python /dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/1_RRBS/0_Pre-processing/1_trim_map_filter/4_merge_symmetric/merge_CpG.py --input $i; done 
```

Now I have merged.cov files that I need to run through the following filtering pipeline again.

#### 5_Methylation Extraction Filtering (13.04.22-20.04.22)...redone on 10.08.23

I want to filter for several different parameters, that mostly deal with the quality of the called CpG sites from bismark. To make sure the called CpG are 'true' sites, we want to keep only those on major chromosomes, filter for depth at each CpG site (get rid of low depth and high depth (mapped to the wrong region)), as well as only keep sites that are within the predicted cut-sites as predicted by seqkit. Above, we made a file that contains the cutsites, but here I want to make a new file that has cutsites only rpesent on major chromsomes:

Below is used to filter sites for low quality (min and max # of reads) as well as filter out C-T SNPs. In the bed file is all SNPs because methylation only occurs at C, so leaving the others in shouldnt be a problem. (Based on Justin's RRBS script)

Run the 1_bismark_filter.sh for each sample (This must be run in the command line to submit jobs):

```bash
for i in $(ls *_val_1_bismark_bt2_pe.CpG_merged.cov.gz | rev | cut -c40- | rev); do sbatch -J ${i} /dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/1_RRBS/0_Pre-processing/1_trim_map_filter/5_filter/1_bismark.filter.sh ${i}; done
```

This also has to be completed for the 'merged bam files' aka the files where the technical replicates were merged. Because of the naming convention, we have to do this once for females and once for males). So, run the 1_bismark_filter.sh for each merged sample (This must be run in the command line to submit jobs):

```bash
for i in $(ls *F.CpG_merged.cov.gz | rev | cut -c19- | rev); do sbatch -J ${i} /dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/1_RRBS/0_Pre-processing/1_trim_map_filter/5_filter/1_bismark.filter.sh ${i}; done
```

```bash
for i in $(ls *M.CpG_merged.cov.gz | rev | cut -c19- | rev); do sbatch -J ${i} /dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/1_RRBS/0_Pre-processing/1_trim_map_filter/5_filter/1_bismark.filter.sh ${i}; done
```

```bash
for i in $(ls *U.CpG_merged.cov.gz | rev | cut -c19- | rev); do sbatch -J ${i} /dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/1_RRBS/0_Pre-processing/1_trim_map_filter/5_filter/1_bismark.filter.sh ${i}; done
```

Get rid of all the old non-merged files (0_sample_names/sample.names.tech.reps.txt)

Now we need to compile the files into a workable format for R, ideally with the sample name included and the data horizontally instead of vertically oriented:

```bash
for i in *COUNTS*; do tr "\n" "\t" < $i > $i".sorted"; done
rm *COUNTS.txt
awk '{print FILENAME" \"" $0"\""; nextfile}' *COUNTS* >> a.COUNTS.merged.tmp
sed -i 's/"//g' a.COUNTS.merged.tmp
awk '{print $1, $3, $5, $7, $9, $11}' a.COUNTS.merged.tmp >> a.COUNTS.clean.tmp
sed -i '1 i\Sample_ID\tRAW\tMAJOR_CHROM\tCUT_SITE_FILTER\tSNP_FILTER\tCOVERAGE_FILTER' a.COUNTS.cleaned.txt
awk -F '__' '$1=$1' OFS="\t" a.COUNTS.clean.tmp >> a.COUNTS.clean.tmp1
awk '{ print $1, $5, $6, $7, $8, $9}' a.COUNTS.clean.tmp1 >> a.COUNTS.clean.txt

rm *tmp*
```

Next, we want to plot the different filtering steps and corresponding counts into a histogram plot to make it easy to see how many CpG sites have been filtered out at each step:

```r
#set working directory
setwd("/home/mueller/Desktop/Notes/documentation/3.1.methylation.filtering/")
list.files()

##plot #CpG sites after each filtering step
#load in data
df <- read_table(file = "a.COUNTS.clean.txt")
df.DE <- read.table("COUNTS.DE.subset.txt", h=T)
df.RU <- read.table("COUNTS.RU.subset.txt", h=T)
#need to get data into a workable format
df.melt <- melt(df.RU)

df.summary <- df.melt %>% 
  group_by(variable) %>%
  summarize(mean=mean(value),sd=sd(value))

#make color palette
pal <- c( wes_palette("Darjeeling1")[1],
          wes_palette("Cavalcanti1")[2],
          wes_palette("Darjeeling1")[5],
          wes_palette("Darjeeling2")[2],
          wes_palette("FantasticFox1")[2],
          wes_palette("FantasticFox1")[5] )

##make histogram
ggplot(df.melt,aes(x=df.melt$Sample_ID, fill=df.melt$variable, y=df.melt$value))+
  geom_bar(stat="identity",position="dodge")+
  theme_classic(base_size=18)+
  scale_fill_manual(values=pal)+
  ylab("Number of CpGs")+
  theme(axis.text.x=(element_text(angle=90,hjust=1)), axis.title.x=element_blank())
```

#### 5_M-Bias Plot (21.04.22)

```bash
for RUN in $(ls *M-bias.txt | sed 's/\..*//g' ); do 

sed -n '/CHG context (R1)/q;p' ${RUN}.*M-bias.txt | egrep -v 'methyl|=|context' \
| grep . | awk -v s=${RUN} '{OFS="\t"}{print s,$0,"R1","CpG"}' > ${RUN}.MBIAS1.txt

sed -n '/CpG context (R2)/,$p' ${RUN}.*M-bias.txt | sed -n '/CHG context (R2)/q;p'  | egrep -v 'methyl|=|context' \
| grep . | awk -v s=${RUN} '{OFS="\t"}{print s,$0,"R2","CpG"}' > ${RUN}.MBIAS2.txt

done
echo -e 'Sample\tPosition\tCountMethylated\tCountUnmethylated\tPercentMethylated\tCoverage\tRead\tContext' > MBias.header
cat MBias.header *MBIAS1.txt > Methylation_Bias-Input_R1.txt
cat MBias.header *MBIAS2.txt > Methylation_Bias-Input_R2.txt

#clean-up
rm MBias.header
rm *M-Bias.txt*
```

And plot in R:

```r
#mbias plotting
bias <- read.table('Methylation_Bias-Input.txt',header=T)

a <- ggplot(bias,aes(x=Position,col=Sample))+
  geom_line(aes(y=PercentMethylated),stat="identity",show.legend=F,size=0.5)+ylab('Percent Methylation')+
  theme_classic(base_size=16)+
  scale_color_viridis(discrete=T,option='turbo')+
  coord_cartesian(ylim=c(0,100))+
  ggtitle('Methylation Along Read Length')

a

b <- ggplot(bias,aes(x=Position,col=Sample,y=log(Coverage)))+
  geom_line(stat="identity",show.legend=F,size=0.5)+ylab('log(Coverage)')+
  theme_classic(base_size=16)+
  scale_color_viridis(discrete=T,option='turbo')+
  ggtitle('Coverage Along Read Length')
b
```

At first, I thought the M-bias plots look weird (see below). But upon closer inspection, they closely reflect the multiqc trimming, which makes sense.

Forward:

For the forward (R1) reads the spike at the beginning reflects that the start position is always a CpG site, which means there is bias for the reasd position, but would not affect the overall results. Then there are smaller spikes along the read length, which is common for RRBS data and could result from i) repetitive regions, ii) mis-mapping, iii) conversion failure for some technical reason at specific CpG loci.

Reverse:

For the reverse reads, the first position having 0% methylation makes sense because all R2 at the 5' end will start with A, and since A cannot be methylated this will bias the reads (see trimming above).

The wider variation towards the 3' end and the unmethylated or methylated sikes at this end usually are caused by the strict adapter trimming where even a single A is removed from the end, this will bias the last position, however, since not all reads are exactly 150bp (some are 147, 148, 149) this looks messy in graph form. For more information on 'weird' M-bias plots, [this]((http://seqanswers.com/forums/showthread.php?t=90956)) is a nice forum. If we take a subset, we can see the individual spikes for each sample:

#### Coverage along Chromosomes (25.04.22)

Next, I want to explore the coverage along the chromsomes of called methlyation sites. I will go first with 1 sample to see if I can get a nice plot.

```bash
#total number of methylated cyotsines
for i in $(ls *.CpG_5mC.cov.gz | rev | cut -c16- | rev);do  zcat ${i}.CpG_5mC.cov.gz | awk -v s=${i} 'BEGIN{FS="\t"; sum=0} {sum+=$5} END{print s, sum}' >> coverage.txt ; done

#total number of unmethylated cytosines
for i in $(ls *.CpG_5mC.cov.gz | rev | cut -c16- | rev);do  zcat ${i}.CpG_5mC.cov.gz | awk -v s=${i} 'BEGIN{FS="\t"; sum=0} {sum+=$6} END{print s, sum}' >> coverage.txt ; done

#total number of cytosines (aka total number of rows)
for i in $(ls *.CpG_5mC.cov.gz | rev | cut -c16- | rev);do  zcat ${i}.CpG_5mC.cov.gz | awk -v s=${i} 'END{print s, NR}' >> total.lines.txt ; done

##combine these into one file with the columns Sample.ID, #methylated, # unmethylated, #total cytosine sites
##then we can plot them in R
```

Next, plotting in R:

```r
bs.genome <- toGRanges(data.frame(chr=c("chr01"), start=c(1), end=c(119023420)))

cov <- read.table("chr01.txt",header=FALSE)
head(cov)

cov_GR <- makeGRangesFromDataFrame(df=cov,ignore.strand=TRUE,seqinfo = NULL, seqnames.field = "V2",start.field = "V3", end.field = "V3",starts.in.df.are.0based=FALSE, keep.extra.columns=TRUE)
cov_GR

samples <- as.vector(unique(cov_GR$V1))
samples

total.tracks <- 28

#Plot
pp <- getDefaultPlotParams(plot.type=4)
pp$leftmargin <- 0.09
kp <- plotKaryotype(plot.type=4, genome = bs.genome, main = "chr01 coverage",plot.params = pp,labels.plotter=NULL)
kpAddChromosomeNames(kp,srt=90, cex=1)


for (i in 1:10) {
  name <- samples[i]
  sub <- cov_GR[grepl(name,cov_GR$V1), ]
  at <- autotrack(current.track = i, total.tracks = 10)
  kpPoints(kp,data=sub,y=sub$V5,cex=0.75,col="black",pch=16,r0=at$r0,r1=at$r1,ymin=0,ymax=200)
  kpAxis(kp,ymin=0,ymax=200,r0=at$r0,r1=at$r1)
}

#histogram of coverage between two chromsomes, or more depending on how you plot
#mean and std of chromosomes

chr01 <- cov %>% 
  group_by(V1,V2) %>%
  summarise(mean = mean(V5),n=n())


ggplot(chr01,aes(x=factor(V1),y=mean,fill=V2))+
  geom_bar(stat="identity",position = "dodge")+
  theme_classic(base_size=16)+
  ggtitle("Average Coverage across Chromosome 01 per Individual")+
  theme(axis.text.x=element_text(angle=90),axis.title.x=element_blank(), legend.position="none")


coverage <- read.table("coverage.txt", header=T)

ggplot(coverage,aes(x=factor(Sample.Id),y=coverage,fill=wes_palette("Darjeeling1")[1]))+
  geom_bar(stat="identity",position = "dodge")+
  theme_classic(base_size=16)+
  ggtitle("Average coverage across all chromsomes per technical replicate")+
  theme(axis.text.x=element_text(angle=90),axis.title.x=element_blank(), legend.position="none")
```

#### Sex Identification/Confirmation against WGS (25.04.22)

I thought it would be a good idea to double check the sex of the individuals as this could point out abnormailities in sequencing, and a way to check against something we already know. To do this, we can pull the W and Z chromosomes out from the bismark.cov.gz file.

```bash
for i in $(ls *.CpG_5mC.cov.gz | rev | cut -c16- | rev);do 
zcat ${i}.CpG_5mC.cov.gz | egrep -w 'chrZ|chrW' | awk -v s=${i} '{OFS="\t"}{print s, $1, $2, $4, $5+$6}' >> Sex_ID.txt
done 
```

One sample RU_13_RT_VN96166_BL_ADL_M__SRR17643184, does not show any calls on the Z chromosome, and very few on chromosome 1. When I check the other docuements it looks fine in the trimming phase, but from mapping the calls only go until chromosome 8. Therefore, I will try mapping again just one this sample and see if it was somehow called incorrectly.

I re-mapped this sample and re-ran methylation extraction and now all the calls appear to be complete and there are calls along the chr.Z as well.

Jochen and I talked about why the females do not show up as half the coverage of the autosomes, one thought is that using the filtered reads is filtering sites in the sutosome that would make it more 2:1 ratio. However, I tried mapping the raw reads on chr.1 and chr.Z, but the outcomes was very similar to the filtered.

All:

Males:

Females:

Unknown
