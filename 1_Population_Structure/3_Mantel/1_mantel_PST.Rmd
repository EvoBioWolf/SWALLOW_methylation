library(dplyr)
library(linkET)

# Load pop information and sample names

```{r}
#sample names
sample_names <- read.table("/dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/0_sample.lists/sample.names.85.txt")
#add sample pops
sample_names <- sample_names %>%
  mutate(pop = case_when(
    grepl("RU_13_R_", V1) ~ "RUr",
    grepl("CH_", V1) ~ "RUe",
    grepl("DE_", V1) ~ "RUe",
    grepl("FI", V1) ~ "RUe",
    grepl("_G_", V1) ~ "GU",
    grepl("_E_", V1) ~ "ER",
    grepl("_S_", V1) ~ "SA",
    grepl("_TV_", V1) ~ "TR",
    grepl("_T_", V1) ~ "TY"))

##Create a list of comparisons
pop.list <- as.data.frame(unique(as.vector(sample_names$pop)))
colnames(pop.list) <- c("pop1")
pop.combo <- tidyr::crossing(var1=pop.list$pop1, var2=pop.list$pop1)
pop.combo <- pop.combo[c(2:7, 10:14, 18:21,26:28, 34:35,42),]

#get explanatory variables set
info <- read_xlsx("/dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/0_sample.lists/NCBI_info_updated_20220727_climate_data.xlsx")
#remove all individuals not used for this analysis
info=info %>%
  dplyr::slice(match(sample_names$V1, info$sample_name))
```

# PST data to run mantel tests on

```{r}
meth <- read.table("/dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowRRBS/2_Divergence/1_PST/0_site_pst/0_pst_variant_c05.txt", header=T)

pst.all <- meth %>%
  dplyr::summarize(
    across(2:22, mean, na.rm = TRUE),
    site_id = min(site.id, order_by = site.id),
    site_count = n()  # Count number of sites in each group
  )

pst.all <- cbind(pop.combo, t(pst.all[1:21]))
colnames(pst.all) <- c("pop1", "pop2", "pst")

pst.all$pst <- as.numeric(pst.all$pst)

pst.copy <- pst.all %>% 
  transmute(pop1 = pst.all$pop2, pop2 = pst.all$pop1, pst = pst.all$pst)
# Combine the two dataframes using bind_rows
pst.all <- bind_rows(pst.all, pst.copy)

# Define the desired population order
pop_levels <- c("SA", "TR", "RUe", "RUr", "GU", "TY", "ER")

# Apply factor levels to both pop1 and pop2
pst.all <- pst.all %>%
  mutate(
    pop1 = factor(pop1, levels = pop_levels),
    pop2 = factor(pop2, levels = pop_levels)
  )

# Pivot the data to a square format
pst_square <- pst.all %>%
  # Ensure we are working with the correct column names
  dplyr::rename(Population_A = pop1, Population_B = pop2) %>%
  pivot_wider(names_from = Population_B, values_from = pst) %>%
  # Arrange rows by the defined factor levels to ensure order
  arrange(Population_A) %>%
  # Convert to dataframe and set row names for the matrix conversion
  as.data.frame()

rownames(pst_square) <- pst_square$Population_A
pst_square$Population_A <- NULL

# Reorder columns to match the row order (pop_levels)
pst_square <- pst_square[, pop_levels]

# Convert to a matrix and then to a 'dist' object 
# This automatically handles the lower-triangular formatting
d.pst.matrix <- as.dist(as.matrix(pst_square))

# View the result
print(d.pst.matrix)
```

## Geographic distance

population based only since PST is inherently pop based

```{r pressure, echo=FALSE}
#geographic distance based on haversine distance (this could also be eucledian, hwoever, haversine takes into acount the sphere of earth)
lat.lon = data.frame(as.numeric(info$Longitude.approx), as.numeric(info$Latitude.approx))

##geographic matrix by population excluding hybrids
info.pop <- as.data.frame(cbind(info$sample_name, as.numeric(info$Longitude.approx), as.numeric(info$Latitude.approx)))
##need this to go in same order as gen_light populations: china, egypt, finland, germany,israel, russia, swiss, usa
info.pop <- info.pop[c(82,11,27,60,35,74,52), c(2:3)]
info.pop$V2 <- as.numeric(info.pop$V2) 
info.pop$V3 <- as.numeric(info.pop$V3) 
row.names(info.pop) <- c("geo.E", "geo.G", "geo.Reu", "geo.Rr", "geo.S",  "geo.T","geo.TV")

geo.pop = distm(info.pop, fun = distHaversine)
d.geo.pop.hav = as.dist(geo.pop)
```
## Ecological distance

Population based distance based on climate data

```{r pressure, echo=FALSE}
info.climate <- read_xlsx("/dss/dsshome1/lxc0B/ra52qed/gitlab/swallow.projects/scripts/0_sample.lists/NCBI_info_updated_20220727_climate_data.xlsx", sheet = "Sheet7")
info.climate=info.climate %>%
  dplyr::slice(match(sample_names$V1, info.climate$sample_name))

#geographic distance based on haversine distance (this could also be eucledian, hwoever, haversine takes into acount the sphere of earth)
eco.df = data.frame(as.numeric(info.climate$tavg), as.numeric(info.climate$tmin), as.numeric(info.climate$tmax), as.numeric(info.climate$prcp), as.numeric(info.climate$pres))

##ecological matrix by population
##need this to go in same order as gen_light populations: china, egypt, finland, germany,israel, russia, swiss, usa
eco.pop <- eco.df[c(82,11,27,60,35,74,52),]
row.names(eco.pop) <- c("eco.E", "eco.G", "eco.Reu", "eco.Rr", "eco.S",  "eco.T","eco.TV")

eco.pop = vegdist(x = eco.pop, method = "bray",na.rm = TRUE)
d.eco.pop.bray = as.dist(eco.pop)
```

## Genetic distance

```{r}
load("/dss/dsslegfs01/pr53da/pr53da-dss-0034/projects/2021_SwallowRRBS/1_Population_Structure/3_Mantel/0_genpop_85_10miss.RData")

```

## Run Population Mantel Tests


```{r pressure, echo=FALSE}

#methylation vs geographic by population
dist.pop <- as.data.frame(t(rbind(d.geo.pop.hav,d.pst.matrix)))

#run Mantel test
meth_geo_pop  = mantel(d.pst.matrix, d.geo.pop.hav, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_geo_pop

#meth_gen
meth_gen_pop  = mantel(d.pst.matrix, d.gen.pop.manual, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_gen_pop

#meth_eco
meth_eco_pop  = mantel(d.pst.matrix, d.eco.pop.bray, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_eco_pop

#geo_gen
geo_gen_pop  = mantel(d.gen.pop.manual, d.geo.pop.hav, method = "spearman", permutations = 9999, na.rm = TRUE)
geo_gen_pop

#eco_gen
eco_gen_pop  = mantel(d.gen.pop.manual, d.eco.pop.bray, method = "spearman", permutations = 9999, na.rm = TRUE)
eco_gen_pop

meth_geo_rm_gen <- mantel.partial(d.pst.matrix, d.geo.pop.hav, d.gen.pop.manual, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_geo_rm_gen

meth_eco_rm_gen <- mantel.partial(d.pst.matrix, d.eco.pop.bray, d.gen.pop.manual, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_eco_rm_gen

meth_gen_rm_geo <- mantel.partial(d.pst.matrix, d.gen.pop.manual, d.geo.pop.hav, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_gen_rm_geo

meth_gen_rm_eco <- mantel.partial(d.pst.matrix, d.gen.pop.manual, d.eco.pop.bray, method = "spearman", permutations = 9999, na.rm = TRUE)
meth_gen_rm_eco


#plot
ggplot(dist.pop, aes(x=d.meth.pop.manhattan, y=d.geo.pop.hav)) + 
  geom_smooth(method="lm")+
  geom_point(color="grey66")+
  xlab("methylation distance")+
  ylab("geographic distance")+
  theme_minimal()

#plot
ggplot(dist.pop, aes(x=d.meth.pop.manhattan, y=d.gen.pop.manual)) + 
  geom_smooth(method="lm")+
  geom_point(color="grey66")+
  xlab("methylation distance")+
  ylab("genetic distance")+
  theme_minimal()

#plot
ggplot(dist.pop, aes(x=d.gen.pop.manual, y=d.geo.pop.hav)) + 
  geom_smooth(method="lm")+
  geom_point(color="grey66")+
  xlab("geographic distance")+
  ylab("genetic distance")+
  theme_minimal()

```



